# MiniOB-2023初赛赛题题解(精简版)

MiniOB是一个偏向硬核的比赛，尽管以下解题过程可能看起来简单，但实际上实现每个步骤都需要耗费大量时间。

### 第一题 basic

注意开发的时候不要破坏原有的功能就可以了

请记得在单元测试中再次测试原有的功能，以确保新功能的引入不会影响现有功能的正常运行。

### 第二题 date

官方也提供了相应的解题方法。

我的整体思路是将格式为'yyyy-MM-dd'的输入解析为日期类型，并将其作为整型数据存储。
具体存储方式为：`yyyy * 10000 + MM * 100 + dd`。

需要注意的是，不要将日期转换为32位时间戳，因为题目要求支持2038年以后和1970年以前的年份。

### 第三题 drop-table

只需删除对应的表文件和索引文件即可。

同时，不要忘了 delete掉db中这个table

### 第四题 update

我的方法是直接删除原有数据并插入更新后的数据。因为在本项目的MVCC更新操作是这样实现的。

虽然本题只要求实现更新单个字段，但在后续的update-mvcc中有多个字段更新的测试用例，
因此尽量在本题中实现更新多个字段的功能。

### 第五题 aggregation-func

聚合函数与普通函数有所不同。普通函数可以直接放在表达式中，但聚合函数不行，
因为聚合函数会改变查询结果的行数。

我的方法是在投影算子（Project Operator）之前添加一个聚合算子（Aggregation Operator），
在聚合算子中实现相应的业务逻辑。

### 第六题 like

只需实现一个LikeExpression。

尽管可以利用标准库中的regex来实现Like的逻辑，但这种做法并不理想，因为在实际的数据库中，需要根据Like表达式来查询索引。

通过状态机的思路来解决Like的逻辑会更加合适。

### 第七题 join-tables

为了完成这个任务，需要实现JoinTuple和JoinOperator。

尽管Miniob已经提供了NestedJoinOperator，但仅使用这个Operator可能导致测试用例超时。

因此，需要实现一个HashJoinOperator来简化像on expr(table1.field) = expr(table2.field)这样的运算。具体逻辑是：分别对左右两张表进行遍历，
对on表达式等号左右的表达式的值求散列值，然后根据散列值进行join操作。

### 第八题 简单子查询

在语法解析阶段，将子查询视为一种表达式。

在制作算子阶段，将子查询的语句转换为相应的查询算子。嵌套设置查询算子。

在执行查询逻辑时，需要检查子查询返回的记录数量是否符合当前表达式的要求。

### 第九题 function

完成本任务主要需要实现以下几个类：

1. FunctionExpression：是expression的一个子类，用于表示函数表达式。
2. SqlFunction：表示特定函数的类，是以下三个函数类的父类。每个FunctionExpression必须包含一个SqlFunction对象。
3. LengthFunction：表示长度函数，内部实现了字符串长度的逻辑。
4. RoundFunction：表示取整函数，内部实现了取整逻辑。
5. DateFormatFunction：表示对日期进行格式化的逻辑。

### 第十题 multi-index

实现这项任务需要重新构建整个索引模块，包括但不限于重新定义Index接口、实现B+树索引、重新设计索引创建的语法解析。

联合索引的逻辑类似于查字典，首先找到第一个字段，然后再查找第二个字段，第三个字段以此类推。
实现联合索引只需将键值分成多个字段即可实现。在比较时，先比较第一个字段，如果第一个字段相等再比较第二个字段。

虽然思路不难，但实际实现起来挺费时间。

如果只是想应付一下，可以只对最左字段创建一个单列索引，作为多列索引。这么做应该也能通过用例。
这题的通过率莫名的高，大家不会都是这么做的吧）

### 第十一题 unique

在插入或更新之前通过索引检查一下是否重复就行。
如果出现重复，就返回一个RC。

### 第十二题 null

我的方法是在系统字段中创建一个新的bitmap类型字段。位图中的每个位从左到右分别表示某个字段是否为空。

如果单纯只是想应付测试用例的话，可以使用一个特殊的值来表示null，但这么做并不符合数据库的设计原则。

### 第十三题 update-select

让set的等号右面支持简单子查询即可，只要把子查询和表达式解析做好，这道题也就水到渠成了

### 第十四题 expression

这个问题涉及到之前几个与表达式相关的问题，其中的难点主要在于语法解析方面。
要如何进行表达式的语法解析，可以参考OceanBase CE的yacc文件。
我对OceanBase CE的yacc文件进行了一定的分析，具体内容可以在[这篇文章](OceanBase-grammer.md)中查看。

### 第十五题 alias

本体并不是很难，在注册tuple schema时将列名换为别名即可

### 第十六题 text

为了让record能够存储可变长度的内容，我将一个大记录切分成多个小记录进行存储。

我给record添加一个头部（header），头部中记录着下一个记录的rid。

记录和记录之间通过rid进行连接，形成一条链表，这样就可以实现可变长度的记录。

### 第十七题 order-by

实现一个OrderbyOperator即可

OrderbyOperator中需要读取所有记录后才能给出排序后的内容，因此需要在open时便获取并缓存子算子中的所有记录

在最后一题中，需要对大量数据进行排序。这显然用到了外部排序的方法。

在实现本题的排序算法时，可以直接实现外部排序算法，这样在最后一题中就可以直接使用了。

### 第十八题 group-by

每个包含groupby的sql语句中都会有至少一个聚合函数，因此可以直接
在之前实现的Aggregation Operator中实现Groupby功能即可。

需要增加的业务逻辑是：将相同的groupby字段的记录放在一起，然后对这些记录进行聚合操作。

如果Aggregation Operator实现的足够好，那么这题就很简单了。

### 第十九题 create-view

这道题目对许多人来说似乎很困难，通过率仅为1%，可以说是本次比赛中通过率最低的题目之一。

完成这道题需要考虑以下几个方面：

1. 在创建视图时，将创建视图的语句单独保存为一个文件，并存储到数据库中。

2. 在对视图进行查询时，将视图名称替换为实际的子查询语句（Stmt）即可。

3. 在对视图进行增、删、改操作之前，需要检查视图和表中的记录是否存在一对一关系。如果不符合条件，则返回失败。

4. 对于插入操作，需要将插入语句中的字段映射到原表的字段，不存在的字段则替换为null。

5. 在删除操作中，只需在where表达式中添加视图中的where条件。

6. 更新操作时，可进行删除+插入操作的方式来实现。

### 第二十题 create-table-select

在Stmt阶段需要把select stmt中的列名提取出来，然后在execute阶段根据提取出来的列名来创建表
之后再执行查询和插入的物理算子

### 第二十一题 complex-sub-query

关联子查询和普通子查询虽然都叫子查询，但是两者的逻辑大不相同。为此，需要在Stmt阶段将两者区分开。

关联子查询更像是一个表达式，而普通子查询则是一个独立的查询语句。

在实现关联子查询时，可以直接将子查询视作一个表达式。在执行物理算子时，将子查询的结果作为一个值传递给父查询。

### 第二十二题 update-mvcc

在对record进行update时，不可以直接在原地修改，而是需要创建一个新的record，并将原来的record在版本号中标记为删除。

### 第二十三题 big-query

前面的题完成这题好像就能顺便能通过了

### 第二十四题 big-write

前面的题完成这题好像也可以顺带通过了

### 第二十五题 big-order-by

之前实现的OrderbyOperator在open时缓存所有记录的方法在这里就行不太通

为实现本题需要将OrderbyOperator中的排序方法升级为外部排序